#version 460
#extension GL_GOOGLE_include_directive : require

#define SHADER_STAGE compute
#pragma shader_stage(compute)

#include "Common/Common.glsl"
#include "Common/MonteCarlo.glsl"
#include "Common/PBR.glsl"

#define SAMPLE_COUNT 4096

layout(constant_id = 0) const uint LOCAL_SIZE_X = 16;
layout(constant_id = 1) const uint LOCAL_SIZE_Y = 16;
layout(constant_id = 2) const uint LOCAL_SIZE_Z = 1;

layout(
    local_size_x_id = 0,
    local_size_y_id = 1,
    local_size_z_id = 2) in;


layout(set = 0, binding = 0, rgba16f) uniform writeonly image2D specularBRDF;

void main()
{
    const vec2 uv = vec2(gl_GlobalInvocationID.xy) / imageSize(specularBRDF);

    const float NoV = uv.x;
    const float roughness = uv.y;

    const vec3 V = vec3(sqrt(1.0 - NoV * NoV), 0.0, NoV);

    const float a = roughness * roughness;

    vec2 scaleOffset;
    for (uint i = 0; i < SAMPLE_COUNT; ++i)
    {
        const vec2 Xi = Hammersley(i, SAMPLE_COUNT);

        const vec3 H = ImportanceSampleGGX(Xi, a * a);

        const vec3 L = -reflect(V, H);

        const float NoL = CosThetaTangent(L);
        const float NoH = CosThetaTangent(H);
        const float VoH = max(dot(V, H), 0.0);

        if (NoL > 0.0)
        {
            const float G = G_Smith(a, NoV, NoL);
            const float G_NoL_PDF = (G * VoH) / (NoH * NoV);

            const float Fc = pow(1.0 - VoH, 5.0);

            scaleOffset.x += (1.0 - Fc) * G_NoL_PDF;
            scaleOffset.y += Fc * G_NoL_PDF;
        }
    }

    scaleOffset /= float(SAMPLE_COUNT);
    
    imageStore(specularBRDF, ivec2(gl_GlobalInvocationID), vec4(scaleOffset, 0.0, 0.0));
}