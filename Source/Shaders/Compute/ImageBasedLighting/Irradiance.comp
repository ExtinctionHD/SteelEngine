#version 460
#extension GL_GOOGLE_include_directive : require

#define SHADER_STAGE compute
#pragma shader_stage(compute)

#include "Common/Common.glsl"
#include "Compute/Compute.glsl"

#define SAMPLE_DELTA 0.05

layout(constant_id = 0) const uint LOCAL_SIZE_X = 16;
layout(constant_id = 1) const uint LOCAL_SIZE_Y = 16;
layout(constant_id = 2) const uint LOCAL_SIZE_Z = 1;

layout(
    local_size_x_id = 0,
    local_size_y_id = 1,
    local_size_z_id = 2) in;

layout(push_constant) uniform PushConstants{
    uint width;
    uint height;
    uint faceIndex;
};

layout(set = 0, binding = 0) uniform samplerCube environmentMap;
layout(set = 1, binding = 0, rgba32f) uniform writeonly image2D irradianceFace;

void main()
{
    const vec2 uv = gl_GlobalInvocationID.xy / vec2(float(width), float(height));
    
    const vec3 direction = GetCubeDirection(faceIndex, uv);
    
    const mat3 TBN = GetTBN(direction);

    uint sampleCount = 0;
    vec3 irradiance = vec3(0.0);

    for(float phi = 0.0; phi < 2.0 * PI; phi += SAMPLE_DELTA)
    {
        for(float theta = 0.0; theta < 0.5 * PI; theta += SAMPLE_DELTA)
        {
            const vec3 tangentDirection = vec3(
                sin(theta) * cos(phi),
                sin(theta) * sin(phi),
                cos(theta));

            const vec3 worldDirection = TangentToWorld(tangentDirection, TBN);

            irradiance += texture(environmentMap, worldDirection).rgb * cos(theta) * sin(theta);

            ++sampleCount;
        }
    }

    irradiance = irradiance / float(sampleCount) * PI;

    imageStore(irradianceFace, ivec2(gl_GlobalInvocationID), vec4(irradiance, 1.0));
}