#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require

#define SHADER_STAGE raygen
#pragma shader_stage(raygen)

#include "PathTracing/PathTracing.h"
#include "PathTracing/PathTracing.glsl"
#include "Common/Common.glsl"
#include "Common/Random.glsl"
#include "Common/PBR.glsl"

#define MIN_BOUNCE_COUNT 3
#define MAX_BOUNCE_COUNT 4

#define RAY_MIN_T 0.001
#define RAY_MAX_T 1000.0

#define MIN_THRESHOLD 0.05

layout(constant_id = 0) const uint MATERIAL_COUNT = 256;

layout(push_constant) uniform PushConstants{
    uint accumIndex;
};

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D renderTarget;
layout(set = 1, binding = 0, rgba8) uniform image2D accumulationTarget;
layout(set = 2, binding = 0) uniform accelerationStructureEXT tlas;
layout(set = 2, binding = 1) uniform CameraData{ Camera camera; };
layout(set = 2, binding = 2) uniform MaterialsData{ Material materials[MATERIAL_COUNT]; };
layout(set = 3, binding = 0) uniform sampler2D textures[];

layout(location = 0) rayPayloadEXT Payload ray;

vec3 GetPrimaryRayOrigin()
{
    const vec4 origin = camera.inverseView * vec4(0.0, 0.0, 0.0, 1.0);
    return origin.xyz;
}

vec3 GetPrimaryRayDireciton(uvec2 seed)
{
    const vec2 pixelSize = 1.0 / gl_LaunchSizeEXT.xy;
    const vec2 uv = pixelSize * gl_LaunchIDEXT.xy + pixelSize * NextVec2(seed);
    const vec2 xy = uv * 2.0 - 1.0;
    const vec4 target = camera.inverseProj * vec4(xy, 1.0, 1.0);
    const vec4 direction = camera.inverseView * vec4(normalize(target.xyz), 0.0);
    return normalize(direction.xyz);
}

void UnpackMaterial(Payload ray, Material mat, inout Surface surface)
{
    surface.TBN = GetTBN(ray.normal, ray.tangent);
    if (mat.normalTexture >= 0)
    {
        vec3 normalSample = texture(textures[nonuniformEXT(mat.normalTexture)], ray.texCoord).rgb * 2.0 - 1.0;
        normalSample = normalize(normalSample * vec3(mat.normalScale, mat.normalScale, 1.0));
        surface.TBN = GetTBN(TangentToWorld(normalSample, surface.TBN));
    }

    surface.baseColor = mat.baseColorFactor.rgb;
    if (mat.baseColorTexture >= 0)
    {
        surface.baseColor = texture(textures[nonuniformEXT(mat.baseColorTexture)], ray.texCoord).rgb;
    }

    surface.roughness = mat.roughnessFactor;
    surface.metallic = mat.metallicFactor;
    if (mat.roughnessMetallicTexture >= 0)
    {
        const vec2 roughnessMetallic = texture(textures[nonuniformEXT(mat.baseColorTexture)], ray.texCoord).gb;
        surface.roughness *= roughnessMetallic.r;
        surface.metallic *= roughnessMetallic.g;
    }

    surface.F0 = mix(DIELECTRIC_F0, surface.baseColor, vec3(surface.metallic));
    surface.a  = surface.roughness * surface.roughness;
    surface.a2 = surface.a * surface.a;
    surface.sw = GetSpecularWeight(surface.baseColor, surface.F0, surface.metallic);
}

void AccumulateAndStore(vec3 value)
{
    const ivec2 targetCoord = ivec2(gl_LaunchIDEXT.xy);

    const vec4 lastValue = imageLoad(accumulationTarget, targetCoord);
	const vec4 result = (vec4(value, 1.0) + accumIndex * lastValue) / (accumIndex + 1.0);

    imageStore(accumulationTarget, targetCoord, result);
    imageStore(renderTarget, targetCoord, result);
}

void main()
{
    uvec2 seed = GetSeed(gl_LaunchIDEXT.xy, accumIndex);

    vec3 origin = GetPrimaryRayOrigin();
    vec3 direction = GetPrimaryRayDireciton(seed);
    float minT = camera.zNear;
    float maxT = camera.zFar;

    uint bounceCount = 0;
    vec3 illumination = vec3(0.0);
    vec3 throughput = vec3(1.0);

    Surface surface;

    do
    {
        traceRayEXT(tlas, gl_RayFlagsOpaqueEXT, 0xFF, 0, 1, 0, 
                origin, minT, direction, maxT, 0);

        if (ray.hitT < 0)
        {
            illumination += throughput * ray.normal.rgb;
            break;
        }

        UnpackMaterial(ray, materials[ray.matId], surface);

        const vec3 p = origin + direction * ray.hitT;
        const vec3 wo = normalize(WorldToTangent(-direction, surface.TBN));

        vec3 wi; float pdf;
        vec3 bsdf = SampleBSDF(surface, wo, wi, pdf, seed);

        if (pdf < EPSILON || IsBlack(bsdf))
        {
            break;
        }

        throughput *= bsdf * abs(dot(wi, ray.normal)) / pdf;
        illumination += throughput;

        origin = p;
        direction = wi;
        minT = RAY_MIN_T;
        maxT = RAY_MAX_T;

        ++bounceCount;

        if (bounceCount > MIN_BOUNCE_COUNT)
        {
            const float threshold = max(MIN_THRESHOLD, 1.0 - MaxComponent(throughput));
            if (NextFloat(seed) < threshold)
            {
                break;
            }
            throughput /= 1.0 - threshold;
        }
    }
    while(bounceCount < MAX_BOUNCE_COUNT);

    illumination = ToneMapping(illumination);
    AccumulateAndStore(illumination);
}
