#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#define SHADER_STAGE raygen
#pragma shader_stage(raygen)

#include "PathTracing/PathTracing.h"
#include "PathTracing/PathTracing.glsl"
#include "Common/Common.glsl"
#include "Common/Random.glsl"

layout(push_constant) uniform PushConstants{
    uint accumIndex;
};

layout(set = 0, binding = 0, rgba8) uniform readonly image2D prevRenderTarget;
layout(set = 0, binding = 1, rgba8) uniform image2D currentRenderTarget;

layout(set = 1, binding = 0) uniform accelerationStructureNV tlas;
layout(set = 1, binding = 1) uniform Camera{ 
    CameraData camera;
};

layout(location = 0) rayPayloadNV Payload raygen;

void main() 
{
    raygen.T = vec3(1);
    raygen.L = vec3(0);
    raygen.depth = 0;
    raygen.seed = GetSeed(gl_LaunchIDNV.xy, accumIndex);

    const vec2 pixelSize = 1.0 / gl_LaunchSizeNV.xy;
    const vec2 uv = pixelSize * gl_LaunchIDNV.xy + pixelSize * NextVec2(raygen.seed);
    const vec2 xy = uv * 2 - 1;

    const vec4 origin = camera.inverseView * vec4(0, 0, 0, 1);
    const vec4 target = camera.inverseProj * vec4(xy, 1, 1) ;
    const vec4 direction = camera.inverseView * vec4(normalize(target.xyz), 0);

    traceNV(tlas, 
            gl_RayFlagsOpaqueNV,
            0xFF,
            0, 0, 0,
            origin.xyz,
            camera.zNear,
            direction.xyz,
            camera.zFar,
            0);

    raygen.L = Tonemapping(raygen.L);

    const vec3 prevColor = imageLoad(prevRenderTarget, ivec2(gl_LaunchIDNV)).rgb;
    const vec3 currentColor = prevColor + (raygen.L - prevColor) / float(accumIndex);

    imageStore(currentRenderTarget, ivec2(gl_LaunchIDNV.xy), vec4(currentColor, 1));
}
