#version 460
#extension GL_NV_ray_tracing : require
#extension GL_GOOGLE_include_directive : require

#define SHADER_STAGE raygen
#pragma shader_stage(raygen)

#include "PathTracing/PathTracing.h"
#include "PathTracing/PathTracing.glsl"
#include "Common/Common.glsl"
#include "Common/Random.glsl"

layout(push_constant) uniform PushConstants{
    uint accumIndex;
};

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D renderTarget;

layout(set = 1, binding = 0, rgba8) uniform image2D accumulationTarget;

layout(set = 2, binding = 0) uniform accelerationStructureNV tlas;
layout(set = 2, binding = 1) uniform CameraData{ Camera camera; };
layout(set = 2, binding = 2) readonly buffer MaterialsData{ Material material[]; };

layout(set = 3, binding = 0) uniform sampler2D textures[];

layout(location = 0) rayPayloadNV Payload ray;

vec3 GetPrimaryRayOrigin()
{
    const vec4 origin = camera.inverseView * vec4(0.0, 0.0, 0.0, 1.0);
    return origin.xyz;
}

vec3 GetPrimaryRayDireciton(uvec2 seed)
{
    const vec2 pixelSize = 1.0 / gl_LaunchSizeNV.xy;
    const vec2 uv = pixelSize * gl_LaunchIDNV.xy + pixelSize * NextVec2(seed);
    const vec2 xy = uv * 2.0 - 1.0;
    const vec4 target = camera.inverseProj * vec4(xy, 1.0, 1.0);
    const vec4 direction = camera.inverseView * vec4(normalize(target.xyz), 0.0);
    return direction.xyz;
}

void AccumulateAndStore(vec3 value)
{
    const ivec2 targetCoord = ivec2(gl_LaunchIDNV.xy);

    const vec4 lastValue = imageLoad(accumulationTarget, targetCoord);
	const vec4 result = (vec4(value, 1.0) + accumIndex * lastValue) / (accumIndex + 1.0);

    imageStore(accumulationTarget, targetCoord, result);
    imageStore(renderTarget, targetCoord, result);
}

void main()
{
    uvec2 seed = GetSeed(gl_LaunchIDNV.xy, accumIndex);

    vec3 origin = GetPrimaryRayOrigin();
    vec3 direction = GetPrimaryRayDireciton(seed);

    uint bounceCount = 0;
    vec3 illumination = vec3(0.0);
    vec3 throughput = vec3(1.0);

    do
    {
        traceNV(tlas, gl_RayFlagsOpaqueNV, 0xFF, 0, 1, 0,
                origin.xyz, camera.zNear, direction.xyz, camera.zFar, 0);

        if (ray.hitT < 0.0)
        {
            illumination += throughput * ray.normal.rgb;
            break;
        }

        illumination = ray.normal.xyz;
        
        ++bounceCount;
    } 
    while(bounceCount < MAX_BOUNCE_COUNT);

    illumination = ToneMapping(illumination);
    AccumulateAndStore(illumination);
}
